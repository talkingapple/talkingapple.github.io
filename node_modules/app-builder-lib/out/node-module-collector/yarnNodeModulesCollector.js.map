{"version":3,"file":"yarnNodeModulesCollector.js","sourceRoot":"","sources":["../../src/node-module-collector/yarnNodeModulesCollector.ts"],"names":[],"mappings":"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","sourcesContent":["import { log } from \"builder-util\"\nimport { Lazy } from \"lazy-val\"\nimport * as path from \"path\"\nimport { NodeModulesCollector } from \"./nodeModulesCollector\"\nimport { PM } from \"./packageManager\"\nimport { PackageJson, YarnDependency } from \"./types\"\n\ntype YarnListJsonLine =\n  | {\n      type: \"tree\"\n      data: {\n        type: \"list\"\n        trees: YarnListTree[]\n      }\n    }\n  | {\n      type: \"info\" | \"warning\" | \"error\"\n      data: string\n    }\n\ninterface YarnListTree {\n  name: string // e.g. \"lodash@4.17.21\"\n  children: YarnListTree[]\n  shadow?: boolean\n  color?: string\n  hint?: any\n  depth?: number\n}\n\nexport class YarnNodeModulesCollector extends NodeModulesCollector<YarnDependency, YarnDependency> {\n  public readonly installOptions = {\n    manager: PM.YARN,\n    lockfile: \"yarn.lock\",\n  }\n\n  protected isHoisted: Lazy<boolean> = new Lazy<boolean>(async () => {\n    return Promise.resolve(true) // Yarn Classic always hoists\n  })\n\n  protected getArgs(): string[] {\n    return [\"list\", \"--production\", \"--json\", \"--depth=Infinity\", \"--no-progress\"]\n  }\n\n  protected async extractProductionDependencyGraph(tree: YarnDependency, dependencyId: string): Promise<void> {\n    if (this.productionGraph[dependencyId]) {\n      return\n    }\n\n    const productionDeps = Object.entries(tree.dependencies || {}).map(async ([, dependency]) => {\n      const dep = {\n        ...dependency,\n        path: await this.cache.realPath[dependency.path],\n      }\n\n      const childDependencyId = this.packageVersionString(dep)\n      await this.extractProductionDependencyGraph(dep, childDependencyId)\n      return childDependencyId\n    })\n\n    const dependencies: string[] = []\n    for (const dep of productionDeps) {\n      dependencies.push(await dep)\n    }\n    this.productionGraph[dependencyId] = { dependencies }\n  }\n\n  protected getDependencyType(pkgName: string, parentPkgJson: PackageJson): \"prod\" | \"dev\" | \"optional\" {\n    if (parentPkgJson.optionalDependencies?.[pkgName]) {\n      return \"optional\"\n    }\n\n    if (parentPkgJson.devDependencies?.[pkgName]) {\n      return \"dev\"\n    }\n\n    if (parentPkgJson.dependencies?.[pkgName]) {\n      return \"prod\"\n    }\n\n    return \"prod\"\n  }\n\n  protected async parseDependenciesTree(jsonBlob: string): Promise<YarnDependency> {\n    const lines = jsonBlob\n      .split(\"\\n\")\n      .map(l => l.trim())\n      .filter(Boolean)\n      .map(l => {\n        try {\n          return JSON.parse(l)\n        } catch {\n          return undefined\n        }\n      })\n      .filter(Boolean) as YarnListJsonLine[]\n\n    const parsedTree: YarnListTree[] | undefined = lines\n      .filter(l => l.type === \"tree\")\n      .map(l => (l.data as any).trees)\n      .shift()\n\n    if (!parsedTree) {\n      throw new Error('Failed to extract Yarn tree: no \"type\":\"tree\" line found in console output')\n    }\n    const rootPkgJson = await this.cache.packageJson[path.join(this.rootDir, \"package.json\")]\n\n    const normalizedTree = await this.normalizeTree({ tree: parsedTree, seen: new Set<string>(), appName: rootPkgJson.name, parentPath: this.rootDir, parentPkgJson: rootPkgJson })\n\n    const dependencies: Record<string, YarnDependency> = {}\n    for (const [name, dep] of Object.entries(normalizedTree)) {\n      dependencies[name] = dep\n    }\n\n    return Promise.resolve({\n      name: rootPkgJson.name,\n      version: rootPkgJson.version,\n      path: this.rootDir,\n      dependencies,\n      workspaces: rootPkgJson?.workspaces,\n    })\n  }\n\n  private async normalizeTree(options: {\n    tree: YarnListTree[]\n    seen: Set<string>\n    appName?: string\n    parentPath: string\n    parentPkgJson?: PackageJson // Add parent's package.json\n  }): Promise<Record<string, YarnDependency>> {\n    const { tree, seen, appName, parentPath = this.rootDir } = options\n    let parentPkgJson = options.parentPkgJson\n    const normalized: Record<string, YarnDependency> = {}\n\n    // Load parent's package.json if not provided\n    if (!parentPkgJson && parentPath) {\n      const parentPkgPath = path.join(parentPath, \"package.json\")\n      try {\n        parentPkgJson = await this.cache.packageJson[parentPkgPath]\n      } catch {\n        // Parent might not have package.json (e.g., root workspace)\n      }\n    }\n\n    for (const node of tree) {\n      const match = node.name.match(/^(.*)@([^@]+)$/)\n      if (!match) {\n        log.debug({ name: node.name }, \"invalid node name format\")\n        continue\n      }\n\n      const [, pkgName, version] = match\n      const id = `${pkgName}@${version}`\n\n      const isShadow = node.shadow && node.color === \"dim\"\n      if (isShadow) {\n        log.debug({ pkgName, version }, \"registering shadow node (hoisted elsewhere), will resolve\")\n      }\n\n      if (seen.has(id)) {\n        continue\n      }\n\n      // Find the correct package path that matches the required version\n      const pkg = await this.locatePackageVersion(parentPath, pkgName, version)\n      const pkgPath = pkg?.packageDir\n\n      if (!pkgPath) {\n        log.warn({ pkgName, version, parentPath }, \"could not find package matching version\")\n        continue\n      }\n\n      seen.add(id)\n\n      const normalizedDep: YarnDependency = {\n        name: pkgName,\n        version,\n        path: pkgPath,\n        dependencies: {},\n        optionalDependencies: {},\n      }\n\n      // Recursively process children, passing this package's info\n      if (node.children && node.children.length > 0) {\n        const childPkgJson = await this.cache.packageJson[path.join(pkgPath, \"package.json\")]\n        const childDeps = await this.normalizeTree({\n          tree: node.children,\n          seen,\n          appName,\n          parentPath: pkgPath,\n          parentPkgJson: childPkgJson, // Pass this package's package.json to children\n        })\n\n        for (const [childDepName, childDep] of Object.entries(childDeps)) {\n          normalizedDep.dependencies![childDepName] = childDep\n        }\n      }\n\n      normalized[pkgName] = normalizedDep\n    }\n\n    return normalized\n  }\n\n  protected async collectAllDependencies(tree: YarnDependency, packageToExclude: string) {\n    const rootPkgJson = await this.cache.packageJson[path.join(this.rootDir, \"package.json\")]\n    const failedPackages = new Set<string>()\n\n    const collect = async (\n      deps: YarnDependency[\"dependencies\"] | YarnDependency[\"optionalDependencies\"] = {},\n      isOptionalDependency: boolean,\n      parentIsOptional: boolean = false\n    ) => {\n      for (const [, value] of Object.entries(deps)) {\n        const isRootOptional = !!rootPkgJson.optionalDependencies?.[value.name]\n        const isDirectRootDep = rootPkgJson.dependencies?.[value.name] || rootPkgJson.optionalDependencies?.[value.name] || rootPkgJson.devDependencies?.[value.name]\n        const treatAsOptional = isOptionalDependency || parentIsOptional || isRootOptional\n\n        const logFields = { name: value.name, version: value.version, path: value.path }\n        const p = await this.cache.realPath[value.path]\n        if (!(await this.cache.exists[p])) {\n          if (treatAsOptional) {\n            log.debug(logFields, \"failed to find optional dependency, skipping\")\n            failedPackages.add(value.name)\n            continue\n          }\n\n          if (!isDirectRootDep) {\n            log.debug(logFields, \"failed to find transitive dependency, treating as optional\")\n            failedPackages.add(value.name)\n            continue\n          }\n\n          const message = \"unable to find module directory; is the path correct?\"\n          log.error(logFields, message)\n          throw new Error(`Failed to resolve module directory for ${value.name}@${value.version} at path: ${value.path}`)\n        }\n\n        let resolvedVersion = value.version\n        const versionMatch = p.match(/[/\\\\]node_modules[/\\\\][^@]+@([^/\\\\]+)[/\\\\]/)\n        if (versionMatch) {\n          resolvedVersion = versionMatch[1]\n          if (resolvedVersion !== value.version) {\n            log.debug({ name: value.name, declared: value.version, resolved: resolvedVersion }, \"resolved actual version from path\")\n          }\n        }\n\n        const m: YarnDependency = {\n          ...value,\n          version: resolvedVersion,\n          path: p,\n        }\n\n        const moduleKey = this.packageVersionString(m)\n        if (this.allDependencies.has(moduleKey)) {\n          continue\n        }\n        this.allDependencies.set(moduleKey, m)\n\n        const childIsOptional = treatAsOptional\n        await collect(m.dependencies, false, childIsOptional)\n        await collect(m.optionalDependencies, true, true)\n      }\n    }\n\n    await collect(tree.dependencies, false, false)\n    await collect(tree.optionalDependencies, true, true)\n\n    // Final cleanup: remove the app package from allDependencies\n    if (packageToExclude) {\n      for (const [key, dep] of this.allDependencies.entries()) {\n        if (dep.name === packageToExclude) {\n          log.debug({ key, name: dep.name }, \"removing app package from allDependencies\")\n          for (const [, d] of Object.entries(dep.dependencies || {})) {\n            this.allDependencies.set(this.packageVersionString(d), d)\n          }\n          this.allDependencies.delete(key)\n        }\n      }\n    }\n\n    if (failedPackages.size > 0) {\n      const cleanDependencies = (deps: Record<string, YarnDependency> = {}) => {\n        for (const [key, dep] of Object.entries(deps)) {\n          if (failedPackages.has(dep.name)) {\n            log.debug({ name: dep.name }, \"removing failed package from tree\")\n            delete deps[key]\n          } else {\n            if (dep.dependencies) {\n              cleanDependencies(dep.dependencies)\n            }\n            if (dep.optionalDependencies) {\n              cleanDependencies(dep.optionalDependencies)\n            }\n          }\n        }\n      }\n\n      cleanDependencies(tree.dependencies)\n      cleanDependencies(tree.optionalDependencies)\n    }\n  }\n}\n"]}