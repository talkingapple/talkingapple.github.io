{"version":3,"file":"moduleCache.js","sourceRoot":"","sources":["../../src/node-module-collector/moduleCache.ts"],"names":[],"mappings":"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","sourcesContent":["import { exists, log } from \"builder-util\"\nimport { PackageJson } from \"./types\"\nimport * as fs from \"fs-extra\"\nimport { resolve } from \"path\"\n\n// Type aliases for clarity\ntype PackageJsonCache = Record<string, Promise<PackageJson>>\ntype RealPathCache = Record<string, Promise<string>>\ntype ExistsCache = Record<string, Promise<boolean>>\ntype LstatCache = Record<string, Promise<fs.Stats>>\ntype RequireResolveCache = Record<string, Promise<string | null>>\n\nexport class ModuleCache {\n  /** Cache for package.json contents (readJson/require) */\n  readonly packageJson: PackageJsonCache\n  /** Cache for resolved real paths (realpath) */\n  readonly realPath: RealPathCache\n  /** Cache for file/directory existence checks */\n  readonly exists: ExistsCache\n  /** Cache for lstat results */\n  readonly lstat: LstatCache\n  /** Cache for require.resolve results (key: \"packageName::fromDir\") */\n  readonly requireResolve: RequireResolveCache\n\n  private readonly packageJsonMap: Map<string, PackageJson> = new Map()\n  private readonly realPathMap: Map<string, string> = new Map()\n  private readonly existsMap: Map<string, boolean> = new Map()\n  private readonly lstatMap: Map<string, fs.Stats> = new Map()\n  private readonly requireResolveMap: Map<string, string | null> = new Map()\n\n  constructor() {\n    this.packageJson = this.createAsyncProxy(this.packageJsonMap, (path: string) => fs.readJson(path))\n    this.exists = this.createAsyncProxy(this.existsMap, (path: string) => exists(path))\n    this.lstat = this.createAsyncProxy(this.lstatMap, (path: string) => fs.lstat(path))\n    this.requireResolve = this.createAsyncProxy(this.requireResolveMap, (cacheKey: string) => {\n      try {\n        const [name, path] = cacheKey.split(\"::\")\n        return Promise.resolve(require.resolve(name, { paths: [path] }))\n      } catch {\n        return Promise.resolve(null)\n      }\n    })\n    this.realPath = this.createAsyncProxy(this.realPathMap, async (path: string) => {\n      const p = resolve(path)\n      try {\n        const stats = await this.lstat[p]\n        if (stats.isSymbolicLink()) {\n          return await fs.realpath(p)\n        }\n        return p\n      } catch (error: any) {\n        log.debug({ filePath: p, message: error.message || error.stack }, \"error resolving path\")\n      }\n      return p\n    })\n  }\n\n  // this allows dot-notation access while still supporting async retrieval\n  // e.g., cache.packageJson[somePath] returns Promise<PackageJson>\n  private createAsyncProxy<T>(map: Map<string, T>, compute: (key: string) => T | Promise<T>): Record<string, Promise<T>> {\n    return new Proxy({} as Record<string, Promise<T>>, {\n      async get(_, key: string) {\n        if (map.has(key)) {\n          return Promise.resolve(map.get(key)!)\n        }\n        return await Promise.resolve(compute(key)).then(value => {\n          map.set(key, value)\n          return value\n        })\n      },\n      set(_, key: string, value: T) {\n        map.set(key, value)\n        return true\n      },\n      has(_, key: string) {\n        return map.has(key)\n      },\n    })\n  }\n}\n"]}