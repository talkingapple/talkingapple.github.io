{"version":3,"file":"npmNodeModulesCollector.js","sourceRoot":"","sources":["../../src/node-module-collector/npmNodeModulesCollector.ts"],"names":[],"mappings":"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","sourcesContent":["import { log } from \"builder-util\"\nimport * as path from \"path\"\nimport { NodeModulesCollector } from \"./nodeModulesCollector\"\nimport { PM } from \"./packageManager\"\nimport { NpmDependency, PackageJson } from \"./types\"\n\nexport class NpmNodeModulesCollector extends NodeModulesCollector<NpmDependency, string> {\n  public readonly installOptions = {\n    manager: PM.NPM,\n    lockfile: \"package-lock.json\",\n  }\n\n  protected getArgs(): string[] {\n    return [\"list\", \"-a\", \"--include\", \"prod\", \"--include\", \"optional\", \"--omit\", \"dev\", \"--json\", \"--long\", \"--silent\"]\n  }\n\n  protected async getDependenciesTree(pm: PM): Promise<NpmDependency> {\n    try {\n      return await super.getDependenciesTree(pm)\n    } catch (error: any) {\n      log.info({ pm: this.installOptions.manager, parser: PM.NPM, error: error.message }, \"unable to process dependency tree, falling back to using manual node_modules traversal\")\n    }\n    // node_modules linker fallback. (Slower due to system ops, so we only use it as a fallback) [such as when corepack env will not allow npm CLI to extract tree]\n    return this.buildNodeModulesTreeManually(this.rootDir)\n  }\n\n  protected async collectAllDependencies(tree: NpmDependency) {\n    for (const [, value] of Object.entries(tree.dependencies || {})) {\n      if (this.isDuplicatedNpmDependency(value)) {\n        continue\n      }\n      this.allDependencies.set(this.packageVersionString(value), value)\n      await this.collectAllDependencies(value)\n    }\n  }\n\n  protected async extractProductionDependencyGraph(tree: NpmDependency, dependencyId: string): Promise<void> {\n    if (this.productionGraph[dependencyId]) {\n      return\n    }\n\n    const isDuplicateDep = this.isDuplicatedNpmDependency(tree)\n    const resolvedDeps = isDuplicateDep ? this.allDependencies.get(dependencyId)?.dependencies : tree.dependencies\n    // Initialize with empty dependencies array first to mark this dependency as \"in progress\"\n    // After initialization, if there are libraries with the same name+version later, they will not be searched recursively again\n    // This will prevents infinite loops when circular dependencies are encountered.\n    this.productionGraph[dependencyId] = { dependencies: [] }\n\n    const collectedDependencies: string[] = []\n    if (resolvedDeps && Object.keys(resolvedDeps).length > 0) {\n      for (const packageName in resolvedDeps) {\n        if (!this.isProdDependency(packageName, tree)) {\n          continue\n        }\n        const dependency = resolvedDeps[packageName]\n        const childDependencyId = this.packageVersionString(dependency)\n        await this.extractProductionDependencyGraph(dependency, childDependencyId)\n        collectedDependencies.push(childDependencyId)\n      }\n    }\n    this.productionGraph[dependencyId] = { dependencies: collectedDependencies }\n  }\n\n  // Check: is package already included as a prod dependency due to another package?\n  // We need to check this to prevent infinite loops in case of duplicated dependencies\n  private isDuplicatedNpmDependency(tree: NpmDependency): boolean {\n    const { _dependencies = {}, dependencies = {} } = tree\n    const isDuplicateDep = Object.keys(_dependencies).length > 0 && Object.keys(dependencies).length === 0\n    return isDuplicateDep\n  }\n\n  protected isProdDependency(packageName: string, tree: NpmDependency) {\n    return tree._dependencies?.[packageName] != null\n  }\n\n  /**\n   * Builds a dependency tree using only package.json dependencies and optionalDependencies.\n   * This skips devDependencies and uses Node.js module resolution (require.resolve).\n   */\n  protected buildNodeModulesTreeManually(baseDir: string): Promise<NpmDependency> {\n    // Track visited packages by their resolved path to prevent infinite loops\n    const visited = new Set<string>()\n\n    /**\n     * Recursively builds dependency tree starting from a package directory.\n     */\n    const buildFromPackage = async (packageDir: string): Promise<NpmDependency> => {\n      const pkgPath = path.join(packageDir, \"package.json\")\n\n      log.debug({ pkgPath }, \"building dependency node from package.json\")\n\n      if (!(await this.cache.exists[pkgPath])) {\n        throw new Error(`package.json not found at ${pkgPath}`)\n      }\n\n      const pkg: PackageJson = await this.cache.packageJson[pkgPath]\n      const resolvedPackageDir = await this.cache.realPath[packageDir]\n\n      // Use resolved path as the unique identifier to prevent circular dependencies\n      if (visited.has(resolvedPackageDir)) {\n        log.debug({ name: pkg.name, version: pkg.version, path: resolvedPackageDir }, \"skipping already visited package\")\n        return {\n          name: pkg.name,\n          version: pkg.version,\n          path: resolvedPackageDir,\n        }\n      }\n\n      visited.add(resolvedPackageDir)\n\n      const prodDeps: Record<string, NpmDependency> = {}\n      const allProdDepNames = {\n        ...pkg.dependencies,\n        ...pkg.optionalDependencies,\n      }\n\n      // Process all production and optional dependencies\n      for (const [depName, depVersion] of Object.entries(allProdDepNames)) {\n        try {\n          const depPath = await this.locatePackageVersion(resolvedPackageDir, depName, depVersion)\n\n          if (!depPath || depPath.packageDir.length === 0) {\n            log.warn({ package: pkg.name, dependency: depName, version: depVersion }, \"dependency not found, skipping\")\n            continue\n          }\n\n          const resolvedDepPath = await this.cache.realPath[depPath.packageDir]\n          const logFields = { package: pkg.name, dependency: depName, resolvedPath: resolvedDepPath }\n\n          // Skip if this dependency resolves to the base directory or any parent we're already processing\n          if (resolvedDepPath === resolvedPackageDir || resolvedDepPath === (await this.cache.realPath[baseDir])) {\n            log.debug(logFields, \"skipping self-referential dependency\")\n            continue\n          }\n\n          log.debug(logFields, \"processing production dependency\")\n\n          // Recursively build the dependency tree for this dependency\n          prodDeps[depName] = await buildFromPackage(resolvedDepPath)\n        } catch (error: any) {\n          log.warn({ package: pkg.name, dependency: depName, error: error.message }, \"failed to process dependency, skipping\")\n        }\n      }\n\n      return {\n        name: pkg.name,\n        version: pkg.version,\n        path: resolvedPackageDir,\n        dependencies: Object.keys(prodDeps).length > 0 ? prodDeps : undefined,\n        optionalDependencies: pkg.optionalDependencies,\n      }\n    }\n\n    return buildFromPackage(baseDir)\n  }\n\n  protected async parseDependenciesTree(jsonBlob: string): Promise<NpmDependency> {\n    return Promise.resolve(JSON.parse(jsonBlob))\n  }\n}\n"]}