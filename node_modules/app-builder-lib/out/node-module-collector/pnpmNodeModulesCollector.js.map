{"version":3,"file":"pnpmNodeModulesCollector.js","sourceRoot":"","sources":["../../src/node-module-collector/pnpmNodeModulesCollector.ts"],"names":[],"mappings":"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","sourcesContent":["import { isEmptyOrSpaces, log } from \"builder-util\"\nimport * as path from \"path\"\nimport { NodeModulesCollector } from \"./nodeModulesCollector\"\nimport { PM } from \"./packageManager\"\nimport { PackageJson, PnpmDependency } from \"./types\"\n\nexport class PnpmNodeModulesCollector extends NodeModulesCollector<PnpmDependency, PnpmDependency> {\n  public readonly installOptions = {\n    manager: PM.PNPM,\n    lockfile: \"pnpm-lock.yaml\",\n  }\n\n  protected getArgs(): string[] {\n    return [\"list\", \"--prod\", \"--json\", \"--depth\", \"Infinity\", \"--long\"]\n  }\n\n  private async getProductionDependencies(depTree: PnpmDependency): Promise<{ path: string; dependencies: Record<string, string>; optionalDependencies: Record<string, string> }> {\n    const packageName = depTree.name || depTree.from\n    if (isEmptyOrSpaces(packageName)) {\n      log.error(depTree, `Cannot determine production dependencies for package with empty name`)\n      throw new Error(`Cannot compute production dependencies for package with empty name: ${packageName}`)\n    }\n\n    const actualPath = await this.locatePackageVersion(depTree.path, packageName, depTree.version).then(it => it?.packageDir)\n    const resolvedLocalPath = await this.cache.realPath[actualPath ?? depTree.path]\n    const p = path.normalize(resolvedLocalPath)\n    const pkgJsonPath = path.join(p, \"package.json\")\n\n    let packageJson: PackageJson\n    try {\n      packageJson = await this.cache.packageJson[pkgJsonPath]\n    } catch (error: any) {\n      log.warn(null, `Failed to read package.json for ${p}: ${error.message}`)\n      return { path: p, dependencies: {}, optionalDependencies: {} }\n    }\n    return { path: p, dependencies: { ...packageJson.dependencies }, optionalDependencies: { ...packageJson.optionalDependencies } }\n  }\n\n  protected async extractProductionDependencyGraph(tree: PnpmDependency, dependencyId: string) {\n    if (this.productionGraph[dependencyId]) {\n      return\n    }\n    this.productionGraph[dependencyId] = { dependencies: [] }\n\n    const packageName = tree.name || tree.from\n\n    const treeDep = { ...(tree.dependencies || {}), ...(tree.optionalDependencies || {}) }\n    const json = packageName === dependencyId ? null : await this.getProductionDependencies(tree)\n    const prodDependencies = json ? { ...json.dependencies, ...json.optionalDependencies } : treeDep\n\n    const collectedDependencies: string[] = []\n    for (const packageName in treeDep) {\n      if (!prodDependencies[packageName]) {\n        continue\n      }\n\n      // Then check if optional dependency path exists (using actual resolved path)\n      const version = json?.optionalDependencies?.[packageName] || tree.optionalDependencies?.[packageName]?.version\n      const actualPath = await this.locatePackageVersion(json?.path ?? tree.path, packageName, version).then(it => it?.packageDir)\n      if (actualPath == null || !(await this.cache.exists[actualPath])) {\n        log.debug({ packageName, version: version, searchPath: actualPath }, `optional dependency not installed, skipping`)\n        continue\n      }\n      const dependency = treeDep[packageName]\n      const childDependencyId = this.packageVersionString(dependency)\n      await this.extractProductionDependencyGraph(dependency, childDependencyId)\n      collectedDependencies.push(childDependencyId)\n    }\n    this.productionGraph[dependencyId] = { dependencies: collectedDependencies }\n  }\n\n  protected async collectAllDependencies(tree: PnpmDependency) {\n    // Collect regular dependencies\n    for (const [key, value] of Object.entries(tree.dependencies || {})) {\n      const json = await this.getProductionDependencies(value)\n      this.allDependencies.set(`${key}@${value.version}`, { ...value, path: json.path })\n      await this.collectAllDependencies(value)\n    }\n\n    // Collect optional dependencies if they exist\n    for (const [key, value] of Object.entries(tree.optionalDependencies || {})) {\n      const json = await this.getProductionDependencies(value)\n      this.allDependencies.set(`${key}@${value.version}`, { ...value, path: json.path })\n      await this.collectAllDependencies(value)\n    }\n  }\n\n  protected packageVersionString(pkg: PnpmDependency): string {\n    // we use 'from' field because 'name' may be different in case of aliases\n    return `${pkg.from}@${pkg.version}`\n  }\n\n  protected async parseDependenciesTree(jsonBlob: string): Promise<PnpmDependency> {\n    const dependencyTree: PnpmDependency[] = JSON.parse(jsonBlob)\n    // pnpm returns an array of dependency trees\n    return Promise.resolve(dependencyTree[0])\n  }\n}\n"]}