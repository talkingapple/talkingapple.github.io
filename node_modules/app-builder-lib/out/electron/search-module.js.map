{"version":3,"file":"search-module.js","sourceRoot":"","sources":["../../src/electron/search-module.ts"],"names":[],"mappings":";;AAiDA,0CAGC;AAQD,oDAGC;AAQD,gDAUC;AAjFD,+BAA8B;AAC9B,kCAAiC;AAEjC,KAAK,UAAU,oBAAoB,CAAC,aAAqB,EAAE,QAAiB,EAAE,iBAA2B;IACvG,IAAI,QAAQ,EAAE,CAAC;QACb,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,KAAK,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAA;IAClE,CAAC;SAAM,IAAI,iBAAiB,EAAE,CAAC;QAC7B,OAAO,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC,CAAA;IAChE,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,CAAA;IACb,CAAC;AACH,CAAC;AAID,KAAK,UAAU,2BAA2B,CACxC,GAAW,EACX,aAAoC,EACpC,QAAiB,EACjB,QAAiB,EACjB,iBAA2B;IAE3B,MAAM,KAAK,GAAa,EAAE,CAAA;IAC1B,IAAI,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;IAErC,OAAO,MAAM,oBAAoB,CAAC,aAAa,EAAE,QAAQ,EAAE,iBAAiB,CAAC,EAAE,CAAC;QAC9E,MAAM,aAAa,GAAG,aAAa,CAAC,aAAa,CAAC,CAAA;QAClD,IAAI,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE,CAAC;YACjC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;QAC3B,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAA;QAC9C,IAAI,UAAU,KAAK,aAAa,IAAI,CAAC,QAAQ,IAAI,KAAK,CAAC,MAAM,IAAI,QAAQ,CAAC,EAAE,CAAC;YAC3E,MAAK;QACP,CAAC;QACD,aAAa,GAAG,UAAU,CAAA;IAC5B,CAAC;IAED,OAAO,KAAK,CAAA;AACd,CAAC;AAED;;;;;;;GAOG;AACI,KAAK,UAAU,eAAe,CAAC,GAAW,EAAE,UAAkB,EAAE,QAAiB;IACtF,MAAM,aAAa,GAA0B,aAAa,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,cAAc,EAAE,UAAU,CAAC,CAAA;IAClH,OAAO,2BAA2B,CAAC,GAAG,EAAE,aAAa,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,CAAA;AACnF,CAAC;AAED;;;;;GAKG;AACI,KAAK,UAAU,oBAAoB,CAAC,GAAW,EAAE,QAAiB;IACvE,MAAM,aAAa,GAA0B,aAAa,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,cAAc,CAAC,CAAA;IACtG,OAAO,2BAA2B,CAAC,GAAG,EAAE,aAAa,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,CAAA;AACnF,CAAC;AAED;;;;;GAKG;AACI,KAAK,UAAU,kBAAkB,CAAC,GAAW;IAClD,KAAK,MAAM,YAAY,IAAI,CAAC,WAAW,EAAE,mBAAmB,EAAE,gBAAgB,EAAE,UAAU,EAAE,WAAW,CAAC,EAAE,CAAC;QACzG,MAAM,aAAa,GAA0B,aAAa,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,YAAY,CAAC,CAAA;QACpG,MAAM,SAAS,GAAG,MAAM,2BAA2B,CAAC,GAAG,EAAE,aAAa,EAAE,SAAS,EAAE,CAAC,CAAC,CAAA;QACrF,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACzB,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAA;QACnC,CAAC;IACH,CAAC;IAED,OAAO,GAAG,CAAA;AACZ,CAAC","sourcesContent":["import * as fs from \"fs-extra\"\nimport * as path from \"node:path\"\n\nasync function shouldContinueSearch(traversedPath: string, rootPath?: string, stopAtPackageJSON?: boolean): Promise<boolean> {\n  if (rootPath) {\n    return Promise.resolve(traversedPath !== path.dirname(rootPath))\n  } else if (stopAtPackageJSON) {\n    return fs.existsSync(path.join(traversedPath, \"package.json\"))\n  } else {\n    return true\n  }\n}\n\ntype PathGeneratorFunction = (traversedPath: string) => string\n\nasync function traverseAncestorDirectories(\n  cwd: string,\n  pathGenerator: PathGeneratorFunction,\n  rootPath?: string,\n  maxItems?: number,\n  stopAtPackageJSON?: boolean\n): Promise<string[]> {\n  const paths: string[] = []\n  let traversedPath = path.resolve(cwd)\n\n  while (await shouldContinueSearch(traversedPath, rootPath, stopAtPackageJSON)) {\n    const generatedPath = pathGenerator(traversedPath)\n    if (fs.existsSync(generatedPath)) {\n      paths.push(generatedPath)\n    }\n\n    const parentPath = path.dirname(traversedPath)\n    if (parentPath === traversedPath || (maxItems && paths.length >= maxItems)) {\n      break\n    }\n    traversedPath = parentPath\n  }\n\n  return paths\n}\n\n/**\n * Find all instances of a given module in node_modules subdirectories while traversing up\n * ancestor directories.\n *\n * @param cwd the initial directory to traverse\n * @param moduleName the Node module name (should work for scoped modules as well)\n * @param rootPath the project's root path. If provided, the traversal will stop at this path.\n */\nexport async function searchForModule(cwd: string, moduleName: string, rootPath?: string): Promise<string[]> {\n  const pathGenerator: PathGeneratorFunction = traversedPath => path.join(traversedPath, \"node_modules\", moduleName)\n  return traverseAncestorDirectories(cwd, pathGenerator, rootPath, undefined, true)\n}\n\n/**\n * Find all instances of node_modules subdirectories while traversing up ancestor directories.\n *\n * @param cwd the initial directory to traverse\n * @param rootPath the project's root path. If provided, the traversal will stop at this path.\n */\nexport async function searchForNodeModules(cwd: string, rootPath?: string): Promise<string[]> {\n  const pathGenerator: PathGeneratorFunction = traversedPath => path.join(traversedPath, \"node_modules\")\n  return traverseAncestorDirectories(cwd, pathGenerator, rootPath, undefined, true)\n}\n\n/**\n * Determine the root directory of a given project, by looking for a directory with an\n * NPM or yarn lockfile or pnpm lockfile.\n *\n * @param cwd the initial directory to traverse\n */\nexport async function getProjectRootPath(cwd: string): Promise<string> {\n  for (const lockFilename of [\"yarn.lock\", \"package-lock.json\", \"pnpm-lock.yaml\", \"bun.lock\", \"bun.lockb\"]) {\n    const pathGenerator: PathGeneratorFunction = traversedPath => path.join(traversedPath, lockFilename)\n    const lockPaths = await traverseAncestorDirectories(cwd, pathGenerator, undefined, 1)\n    if (lockPaths.length > 0) {\n      return path.dirname(lockPaths[0])\n    }\n  }\n\n  return cwd\n}\n"]}